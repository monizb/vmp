import { getDatabase } from '../config/database.js';
import { Vulnerability } from '../models/Vulnerability.js';
import { DueDateSettingsService } from './DueDateSettingsService.js';
import { ObjectId } from 'mongodb';

export class VulnerabilityService {
  constructor() {
    this.collectionName = 'vulnerabilities';
    this.dueDateSettingsService = new DueDateSettingsService();
  }

  async getCollection() {
    const db = await getDatabase();
    return db.collection(this.collectionName);
  }

  async getAll(filters = {}, pagination = {}) {
    const collection = await this.getCollection();
    let query = {};
    
    if (filters.applicationId) {
      query.applicationId = new ObjectId(filters.applicationId);
    }
    
    if (filters.reportId) {
      query.reportId = new ObjectId(filters.reportId);
    }
    
    if (filters.status) {
      query.status = filters.status;
    }
    
    if (filters.internalStatus) {
      query.internalStatus = filters.internalStatus;
    }
    
    if (filters.severity) {
      query.severity = filters.severity;
    }
    
    if (filters.assignedTo) {
      if (filters.assignedTo === 'unassigned') {
        query.$or = [
          ...(query.$or || []),
          { assignedToUserId: { $exists: false } },
          { assignedToUserId: null }
        ];
      } else {
        query.assignedToUserId = new ObjectId(filters.assignedTo);
      }
    }

    if (filters.year) {
      query.year = parseInt(filters.year);
    }
    
    if (filters.search) {
      const searchRegex = new RegExp(filters.search, 'i');
      query.$or = [
        { title: searchRegex },
        { description: searchRegex },
        { cve: { $in: [searchRegex] } },
        { cwe: { $in: [searchRegex] } }
      ];
    }
    
    const page = pagination.page || 1;
    const pageSize = pagination.pageSize || 10;
    const skip = (page - 1) * pageSize;
    
    const [vulnerabilities, total] = await Promise.all([
      collection.find(query).sort({ year: -1, createdAt: -1 }).skip(skip).limit(pageSize).toArray(),
      collection.countDocuments(query)
    ]);
    
    return {
      items: vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON()),
      total,
      page,
      pageSize
    };
  }

  async getById(id) {
    const collection = await this.getCollection();
    const vulnerability = await collection.findOne({ _id: new ObjectId(id) });
    return vulnerability ? Vulnerability.fromMongo(vulnerability).toJSON() : null;
  }

  async create(vulnerabilityData) {
    const collection = await this.getCollection();
    const normalized = { ...vulnerabilityData };
    if (normalized.applicationId) normalized.applicationId = new ObjectId(normalized.applicationId);
    if (normalized.reportId) normalized.reportId = new ObjectId(normalized.reportId);
    if (normalized.assignedToUserId) normalized.assignedToUserId = new ObjectId(normalized.assignedToUserId);
    
    // Auto-assign due date if not provided and severity is available
    if (!normalized.dueDate && normalized.severity) {
      const autoAssignedDueDate = await this.dueDateSettingsService.calculateDueDate(
        normalized.severity, 
        normalized.discoveredDate || new Date()
      );
      if (autoAssignedDueDate) {
        normalized.dueDate = autoAssignedDueDate;
      }
    }
    
    const vulnerability = new Vulnerability(normalized);
    const result = await collection.insertOne(vulnerability.toMongo());
    return Vulnerability.fromMongo({ ...vulnerability.toMongo(), _id: result.insertedId }).toJSON();
  }

  async update(id, vulnerabilityData) {
    const collection = await this.getCollection();
    const updateData = {
      ...vulnerabilityData,
      updatedAt: new Date()
    };
    
    // Handle status changes
    if (vulnerabilityData.status === 'Fixed' && !updateData.resolvedDate) {
      updateData.resolvedDate = new Date();
    }
    
    // Auto-assign due date if severity changed and no due date is set
    if (vulnerabilityData.severity && !vulnerabilityData.dueDate) {
      const currentVuln = await collection.findOne({ _id: new ObjectId(id) });
      if (currentVuln && !currentVuln.dueDate) {
        const autoAssignedDueDate = await this.dueDateSettingsService.calculateDueDate(
          vulnerabilityData.severity,
          currentVuln.discoveredDate || new Date()
        );
        if (autoAssignedDueDate) {
          updateData.dueDate = autoAssignedDueDate;
        }
      }
    }
    
    if (updateData.applicationId) updateData.applicationId = new ObjectId(updateData.applicationId);
    if (updateData.reportId) updateData.reportId = new ObjectId(updateData.reportId);
    if (updateData.assignedToUserId) updateData.assignedToUserId = new ObjectId(updateData.assignedToUserId);
    
    const result = await collection.findOneAndUpdate(
      { _id: new ObjectId(id) },
      { $set: updateData },
      { returnDocument: 'after' }
    );
    
    return result.value ? Vulnerability.fromMongo(result.value).toJSON() : null;
  }

  async delete(id) {
    const collection = await this.getCollection();
    const result = await collection.deleteOne({ _id: new ObjectId(id) });
    return result.deletedCount > 0;
  }

  async getByApplication(applicationId) {
    const collection = await this.getCollection();
    const vulnerabilities = await collection.find({ applicationId: new ObjectId(applicationId) }).sort({ year: -1, createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getByReport(reportId) {
    const collection = await this.getCollection();
    const vulnerabilities = await collection.find({ reportId: new ObjectId(reportId) }).sort({ year: -1, createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getByStatus(status) {
    const collection = await this.getCollection();
    const vulnerabilities = await collection.find({ status }).sort({ year: -1, createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getBySeverity(severity) {
    const collection = await this.getCollection();
    const vulnerabilities = await collection.find({ severity }).sort({ year: -1, createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getByYear(year) {
    const collection = await this.getCollection();
    const vulnerabilities = await collection.find({ year: parseInt(year) }).sort({ createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getByAssignee(userId) {
    const collection = await this.getCollection();
    const vulnerabilities = await collection.find({ assignedToUserId: new ObjectId(userId) }).sort({ year: -1, createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getRelatedVulnerabilities(vulnerabilityId) {
    const collection = await this.getCollection();
    const vulnerability = await collection.findOne({ _id: new ObjectId(vulnerabilityId) });
    if (!vulnerability) return [];

    // Find vulnerabilities with the same title or CVE/CWE
    const query = {
      _id: { $ne: new ObjectId(vulnerabilityId) },
      $or: [
        { title: vulnerability.title },
        { cve: { $in: vulnerability.cve } },
        { cwe: { $in: vulnerability.cwe } }
      ]
    };

    const relatedVulns = await collection.find(query).sort({ year: -1, createdAt: -1 }).toArray();
    return relatedVulns.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getOverdue() {
    const collection = await this.getCollection();
    const today = new Date();
    const vulnerabilities = await collection.find({
      dueDate: { $lt: today },
      status: { $nin: ['Fixed', 'Closed'] }
    }).sort({ year: -1, createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getDueThisWeek() {
    const collection = await this.getCollection();
    const today = new Date();
    const weekFromNow = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);
    const vulnerabilities = await collection.find({
      dueDate: { $gte: today, $lte: weekFromNow },
      status: { $nin: ['Fixed', 'Closed'] }
    }).sort({ year: -1, createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getUpcomingRetests() {
    const collection = await this.getCollection();
    const today = new Date();
    const monthFromNow = new Date(today.getTime() + 30 * 24 * 60 * 60 * 1000);
    const vulnerabilities = await collection.find({
      status: 'Fixed',
      resolvedDate: { $exists: true, $ne: null }
    }).sort({ year: -1, createdAt: -1 }).toArray();
    
    // Filter for vulnerabilities that need retesting (30 days after resolution)
    return vulnerabilities
      .filter(vuln => {
        const retestDate = new Date(vuln.resolvedDate.getTime() + 30 * 24 * 60 * 60 * 1000);
        return retestDate >= today && retestDate <= monthFromNow;
      })
      .map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getStats() {
    const collection = await this.getCollection();
    const stats = await collection.aggregate([
      {
        $group: {
          _id: null,
          total: { $sum: 1 },
          bySeverity: {
            $push: {
              severity: '$severity',
              status: '$status'
            }
          },
          byStatus: {
            $push: '$status'
          },
          byYear: {
            $push: '$year'
          }
        }
      }
    ]).toArray();

    if (stats.length === 0) {
      return {
        total: 0,
        bySeverity: {},
        byStatus: {},
        byYear: {}
      };
    }

    const stat = stats[0];
    const bySeverity = {};
    const byStatus = {};
    const byYear = {};

    stat.bySeverity.forEach(item => {
      bySeverity[item.severity] = (bySeverity[item.severity] || 0) + 1;
    });

    stat.byStatus.forEach(status => {
      byStatus[status] = (byStatus[status] || 0) + 1;
    });

    stat.byYear.forEach(year => {
      byYear[year] = (byYear[year] || 0) + 1;
    });

    return {
      total: stat.total,
      bySeverity,
      byStatus,
      byYear
    };
  }

  buildQueryFromFilters(filters = {}) {
    const query = {};
    if (filters.applicationId) query.applicationId = new ObjectId(filters.applicationId);
    if (filters.reportId) query.reportId = new ObjectId(filters.reportId);
    if (filters.status) query.status = filters.status;
    if (filters.internalStatus) query.internalStatus = filters.internalStatus;
    if (filters.severity) query.severity = filters.severity;
    if (filters.assignedTo) {
      if (filters.assignedTo === 'unassigned') {
        query.$or = [
          ...(query.$or || []),
          { assignedToUserId: { $exists: false } },
          { assignedToUserId: null }
        ];
      } else {
        query.assignedToUserId = new ObjectId(filters.assignedTo);
      }
    }
    if (filters.startDate || filters.endDate) {
      query.discoveredDate = {};
      if (filters.startDate) query.discoveredDate.$gte = new Date(filters.startDate);
      if (filters.endDate) query.discoveredDate.$lte = new Date(filters.endDate);
    }
    return query;
  }

  async getAnalyticsSummary(filters = {}) {
    const collection = await this.getCollection();
    const query = this.buildQueryFromFilters(filters);
    const docs = await collection.find(query).toArray();
    const today = new Date();

    const isOpen = (v) => v.status !== 'Fixed' && v.status !== 'Closed';

    const summary = {
      total: docs.length,
      open: docs.filter(isOpen).length,
      overdue: docs.filter((v) => isOpen(v) && v.dueDate && new Date(v.dueDate) < today).length,
      bySeverity: {},
      byStatus: {},
      byInternalStatus: {},
      byApp: {},
      byTeam: {},
      sla: { openNotOverdue: 0, openTotalWithDueDate: 0, compliancePercent: 0 },
    };

    docs.forEach((v) => {
      summary.bySeverity[v.severity] = (summary.bySeverity[v.severity] || 0) + 1;
      summary.byStatus[v.status] = (summary.byStatus[v.status] || 0) + 1;
      if (v.internalStatus) summary.byInternalStatus[v.internalStatus] = (summary.byInternalStatus[v.internalStatus] || 0) + 1;
      if (v.applicationId) summary.byApp[v.applicationId.toString()] = (summary.byApp[v.applicationId.toString()] || 0) + 1;
      if (isOpen(v) && v.dueDate) {
        summary.sla.openTotalWithDueDate += 1;
        if (new Date(v.dueDate) >= today) summary.sla.openNotOverdue += 1;
      }
    });

    summary.sla.compliancePercent = summary.sla.openTotalWithDueDate > 0
      ? Math.round((summary.sla.openNotOverdue / summary.sla.openTotalWithDueDate) * 100)
      : 100;

    // byTeam via applications
    const db = await getDatabase();
    const apps = await db.collection('applications').find({}).toArray();
    const appIdToTeamId = {};
    const teamIdToCount = {};
    apps.forEach((a) => { appIdToTeamId[a._id.toString()] = a.teamId?.toString() || null; });
    Object.entries(summary.byApp).forEach(([appId, count]) => {
      const teamId = appIdToTeamId[appId];
      if (teamId) teamIdToCount[teamId] = (teamIdToCount[teamId] || 0) + count;
    });
    summary.byTeam = teamIdToCount;

    return summary;
  }

  async getTimeSeries({ interval = 'month', periods = 6, filters = {} } = {}) {
    const collection = await this.getCollection();
    const end = filters.endDate ? new Date(filters.endDate) : new Date();
    const start = filters.startDate ? new Date(filters.startDate) : new Date(end);
    if (!filters.startDate) {
      if (interval === 'week') start.setDate(end.getDate() - periods * 7);
      else start.setMonth(end.getMonth() - periods + 1, 1);
    }

    const query = this.buildQueryFromFilters({ ...filters, startDate: start, endDate: end });
    // Pull wider set to count fixes within range as well
    const docs = await collection.find({}).toArray();

    const buckets = [];
    const formatKey = (d) => {
      if (interval === 'week') {
        const y = d.getFullYear();
        const onejan = new Date(d.getFullYear(), 0, 1);
        const week = Math.ceil((((d - onejan) / 86400000) + onejan.getDay() + 1) / 7);
        return `${y}-W${String(week).padStart(2, '0')}`;
      }
      return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
    };

    const advance = (d) => {
      const nd = new Date(d);
      if (interval === 'week') nd.setDate(nd.getDate() + 7);
      else nd.setMonth(nd.getMonth() + 1);
      return nd;
    };

    // Init buckets
    let cursor = new Date(start);
    while (cursor <= end) {
      buckets.push({ period: formatKey(cursor), opened: 0, fixed: 0 });
      cursor = advance(cursor);
    }
    const indexByKey = Object.fromEntries(buckets.map((b, i) => [b.period, i]));

    docs.forEach((v) => {
      const disc = v.discoveredDate && new Date(v.discoveredDate);
      if (disc && disc >= start && disc <= end) {
        const key = formatKey(interval === 'week' ? new Date(disc) : new Date(disc.getFullYear(), disc.getMonth(), 1));
        if (indexByKey[key] !== undefined) buckets[indexByKey[key]].opened += 1;
      }
      const res = v.resolvedDate && new Date(v.resolvedDate);
      if (res && res >= start && res <= end) {
        const key = formatKey(interval === 'week' ? new Date(res) : new Date(res.getFullYear(), res.getMonth(), 1));
        if (indexByKey[key] !== undefined) buckets[indexByKey[key]].fixed += 1;
      }
    });

    return { start, end, interval, buckets };
  }

  async getMTTR(filters = {}) {
    const collection = await this.getCollection();
    const query = this.buildQueryFromFilters(filters);
    const docs = await collection.find(query).toArray();
    const durations = [];
    const bySeverity = {};
    docs.forEach((v) => {
      if (v.discoveredDate && v.resolvedDate) {
        const d = Math.max(0, Math.round((new Date(v.resolvedDate) - new Date(v.discoveredDate)) / (1000 * 60 * 60 * 24)));
        durations.push(d);
        const sev = v.severity || 'Unknown';
        bySeverity[sev] = bySeverity[sev] || [];
        bySeverity[sev].push(d);
      }
    });
    const average = durations.length ? Math.round(durations.reduce((a, b) => a + b, 0) / durations.length) : 0;
    const median = durations.length ? durations.sort((a, b) => a - b)[Math.floor(durations.length / 2)] : 0;
    const severity = Object.fromEntries(Object.entries(bySeverity).map(([k, arr]) => {
      const avg = arr.length ? Math.round(arr.reduce((a, b) => a + b, 0) / arr.length) : 0;
      return [k, { average: avg }];
    }));
    return { average, median, bySeverity: severity };
  }

  async getTopApps(limit = 5, filters = {}) {
    const collection = await this.getCollection();
    const query = this.buildQueryFromFilters(filters);
    const docs = await collection.find(query).toArray();
    const openCounts = {};
    docs.forEach((v) => {
      if (v.status !== 'Fixed' && v.status !== 'Closed' && v.applicationId) {
        const k = v.applicationId.toString();
        openCounts[k] = (openCounts[k] || 0) + 1;
      }
    });
    const entries = Object.entries(openCounts).sort((a, b) => b[1] - a[1]).slice(0, limit);
    const db = await getDatabase();
    const appIds = entries.map(([id]) => new ObjectId(id));
    const apps = await db.collection('applications').find({ _id: { $in: appIds } }).toArray();
    const idToName = Object.fromEntries(apps.map((a) => [a._id.toString(), a.name]));
    return entries.map(([id, count]) => ({ applicationId: id, name: idToName[id] || id, openCount: count }));
  }
  async getVulnerabilitiesByYearGrouped(applicationId) {
    const collection = await this.getCollection();
    const vulnerabilities = await collection.find({ 
      applicationId: new ObjectId(applicationId) 
    }).sort({ year: -1, createdAt: -1 }).toArray();
    
    const groupedVulns = {};
    vulnerabilities.forEach(vuln => {
      const year = vuln.year || new Date(vuln.createdAt).getFullYear();
      if (!groupedVulns[year]) {
        groupedVulns[year] = [];
      }
      groupedVulns[year].push(Vulnerability.fromMongo(vuln).toJSON());
    });
    
    return groupedVulns;
  }
} 