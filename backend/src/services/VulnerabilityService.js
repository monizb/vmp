import { getDatabase } from '../config/database.js';
import { Vulnerability } from '../models/Vulnerability.js';
import { ObjectId } from 'mongodb';

export class VulnerabilityService {
  constructor() {
    this.collectionName = 'vulnerabilities';
  }

  async getCollection() {
    const db = await getDatabase();
    return db.collection(this.collectionName);
  }

  async getAll(filters = {}, pagination = {}) {
    const collection = await this.getCollection();
    let query = {};
    
    if (filters.applicationId) {
      query.applicationId = new ObjectId(filters.applicationId);
    }
    
    if (filters.reportId) {
      query.reportId = new ObjectId(filters.reportId);
    }
    
    if (filters.status) {
      query.status = filters.status;
    }
    
    if (filters.internalStatus) {
      query.internalStatus = filters.internalStatus;
    }
    
    if (filters.severity) {
      query.severity = filters.severity;
    }
    
    if (filters.assignedTo) {
      query.assignedToUserId = new ObjectId(filters.assignedTo);
    }

    if (filters.year) {
      query.year = parseInt(filters.year);
    }
    
    if (filters.search) {
      const searchRegex = new RegExp(filters.search, 'i');
      query.$or = [
        { title: searchRegex },
        { description: searchRegex },
        { cve: { $in: [searchRegex] } },
        { cwe: { $in: [searchRegex] } }
      ];
    }
    
    const page = pagination.page || 1;
    const pageSize = pagination.pageSize || 10;
    const skip = (page - 1) * pageSize;
    
    const [vulnerabilities, total] = await Promise.all([
      collection.find(query).sort({ year: -1, createdAt: -1 }).skip(skip).limit(pageSize).toArray(),
      collection.countDocuments(query)
    ]);
    
    return {
      items: vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON()),
      total,
      page,
      pageSize
    };
  }

  async getById(id) {
    const collection = await this.getCollection();
    const vulnerability = await collection.findOne({ _id: new ObjectId(id) });
    return vulnerability ? Vulnerability.fromMongo(vulnerability).toJSON() : null;
  }

  async create(vulnerabilityData) {
    const collection = await this.getCollection();
    const normalized = { ...vulnerabilityData };
    if (normalized.applicationId) normalized.applicationId = new ObjectId(normalized.applicationId);
    if (normalized.reportId) normalized.reportId = new ObjectId(normalized.reportId);
    if (normalized.assignedToUserId) normalized.assignedToUserId = new ObjectId(normalized.assignedToUserId);
    const vulnerability = new Vulnerability(normalized);
    const result = await collection.insertOne(vulnerability.toMongo());
    return Vulnerability.fromMongo({ ...vulnerability.toMongo(), _id: result.insertedId }).toJSON();
  }

  async update(id, vulnerabilityData) {
    const collection = await this.getCollection();
    const updateData = {
      ...vulnerabilityData,
      updatedAt: new Date()
    };
    
    // Handle status changes
    if (vulnerabilityData.status === 'Fixed' && !updateData.resolvedDate) {
      updateData.resolvedDate = new Date();
    }
    
    if (updateData.applicationId) updateData.applicationId = new ObjectId(updateData.applicationId);
    if (updateData.reportId) updateData.reportId = new ObjectId(updateData.reportId);
    if (updateData.assignedToUserId) updateData.assignedToUserId = new ObjectId(updateData.assignedToUserId);
    
    const result = await collection.findOneAndUpdate(
      { _id: new ObjectId(id) },
      { $set: updateData },
      { returnDocument: 'after' }
    );
    
    return result.value ? Vulnerability.fromMongo(result.value).toJSON() : null;
  }

  async delete(id) {
    const collection = await this.getCollection();
    const result = await collection.deleteOne({ _id: new ObjectId(id) });
    return result.deletedCount > 0;
  }

  async getByApplication(applicationId) {
    const collection = await this.getCollection();
    const vulnerabilities = await collection.find({ applicationId: new ObjectId(applicationId) }).sort({ year: -1, createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getByReport(reportId) {
    const collection = await this.getCollection();
    const vulnerabilities = await collection.find({ reportId: new ObjectId(reportId) }).sort({ year: -1, createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getByStatus(status) {
    const collection = await this.getCollection();
    const vulnerabilities = await collection.find({ status }).sort({ year: -1, createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getBySeverity(severity) {
    const collection = await this.getCollection();
    const vulnerabilities = await collection.find({ severity }).sort({ year: -1, createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getByYear(year) {
    const collection = await this.getCollection();
    const vulnerabilities = await collection.find({ year: parseInt(year) }).sort({ createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getByAssignee(userId) {
    const collection = await this.getCollection();
    const vulnerabilities = await collection.find({ assignedToUserId: new ObjectId(userId) }).sort({ year: -1, createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getRelatedVulnerabilities(vulnerabilityId) {
    const collection = await this.getCollection();
    const vulnerability = await collection.findOne({ _id: new ObjectId(vulnerabilityId) });
    if (!vulnerability) return [];

    // Find vulnerabilities with the same title or CVE/CWE
    const query = {
      _id: { $ne: new ObjectId(vulnerabilityId) },
      $or: [
        { title: vulnerability.title },
        { cve: { $in: vulnerability.cve } },
        { cwe: { $in: vulnerability.cwe } }
      ]
    };

    const relatedVulns = await collection.find(query).sort({ year: -1, createdAt: -1 }).toArray();
    return relatedVulns.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getOverdue() {
    const collection = await this.getCollection();
    const today = new Date();
    const vulnerabilities = await collection.find({
      dueDate: { $lt: today },
      status: { $nin: ['Fixed', 'Closed'] }
    }).sort({ year: -1, createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getDueThisWeek() {
    const collection = await this.getCollection();
    const today = new Date();
    const weekFromNow = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);
    const vulnerabilities = await collection.find({
      dueDate: { $gte: today, $lte: weekFromNow },
      status: { $nin: ['Fixed', 'Closed'] }
    }).sort({ year: -1, createdAt: -1 }).toArray();
    return vulnerabilities.map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getUpcomingRetests() {
    const collection = await this.getCollection();
    const today = new Date();
    const monthFromNow = new Date(today.getTime() + 30 * 24 * 60 * 60 * 1000);
    const vulnerabilities = await collection.find({
      status: 'Fixed',
      resolvedDate: { $exists: true, $ne: null }
    }).sort({ year: -1, createdAt: -1 }).toArray();
    
    // Filter for vulnerabilities that need retesting (30 days after resolution)
    return vulnerabilities
      .filter(vuln => {
        const retestDate = new Date(vuln.resolvedDate.getTime() + 30 * 24 * 60 * 60 * 1000);
        return retestDate >= today && retestDate <= monthFromNow;
      })
      .map(vuln => Vulnerability.fromMongo(vuln).toJSON());
  }

  async getStats() {
    const collection = await this.getCollection();
    const stats = await collection.aggregate([
      {
        $group: {
          _id: null,
          total: { $sum: 1 },
          bySeverity: {
            $push: {
              severity: '$severity',
              status: '$status'
            }
          },
          byStatus: {
            $push: '$status'
          },
          byYear: {
            $push: '$year'
          }
        }
      }
    ]).toArray();

    if (stats.length === 0) {
      return {
        total: 0,
        bySeverity: {},
        byStatus: {},
        byYear: {}
      };
    }

    const stat = stats[0];
    const bySeverity = {};
    const byStatus = {};
    const byYear = {};

    stat.bySeverity.forEach(item => {
      bySeverity[item.severity] = (bySeverity[item.severity] || 0) + 1;
    });

    stat.byStatus.forEach(status => {
      byStatus[status] = (byStatus[status] || 0) + 1;
    });

    stat.byYear.forEach(year => {
      byYear[year] = (byYear[year] || 0) + 1;
    });

    return {
      total: stat.total,
      bySeverity,
      byStatus,
      byYear
    };
  }

  async getVulnerabilitiesByYearGrouped(applicationId) {
    const collection = await this.getCollection();
    const vulnerabilities = await collection.find({ 
      applicationId: new ObjectId(applicationId) 
    }).sort({ year: -1, createdAt: -1 }).toArray();
    
    const groupedVulns = {};
    vulnerabilities.forEach(vuln => {
      const year = vuln.year || new Date(vuln.createdAt).getFullYear();
      if (!groupedVulns[year]) {
        groupedVulns[year] = [];
      }
      groupedVulns[year].push(Vulnerability.fromMongo(vuln).toJSON());
    });
    
    return groupedVulns;
  }
} 